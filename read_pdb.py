#!/usr/bin/python

from string import *
from os import rename
from random import random
from math import sqrt

def position_read(line,start,end=0):
    """
    Read line from start postition to end position
    """
    if end==0:
        end = start
    return line[start-1:end]

class charmm_pdb_line:
    """
    Read different fields of a pdb generated by charmm
    """

    def __init__(self,line=""):

        if len(line) == 77 and position_read(line,1,4) == 'ATOM':
            line = line[:-1] + "    \n"            
            
        if len(line) != 81:
            line = " "*80+"\n"

        self.ATOM = position_read(line,1,6)
        self.serial = position_read(line,7,11)
        self.name = position_read(line,13,16)
        self.altloc = position_read(line,17)
        self.resname = position_read(line,18,21)
        self.chain = position_read(line,22)

        self.resnum = position_read(line,23,26)
        self.charmm_resnum = position_read(line,24,27)
        self.icode = position_read(line,27)
        if self.resnum != "    " and (int(self.resnum) < int(self.charmm_resnum)):
            self.resnum = self.charmm_resnum
            self.icode = " "

        self.x = position_read(line,31,38)
        self.y = position_read(line,39,46)
        self.z = position_read(line,47,54)
        self.occ = position_read(line,55,60)
        self.tempfac = position_read(line,61,66)
        self.segid = position_read(line,73,76)
        self.elename = position_read(line,77,78)
        self.charge = position_read(line,79,80)

        self.data = self.write()        

    def write(self):

        if self.resnum==self.charmm_resnum:
            line = self.ATOM+self.serial+" "+self.name+self.altloc+self.resname
            line = line+self.chain+" "+self.resnum+"   "
            line = line+self.x+self.y+self.z+self.occ+self.tempfac+"      "
            line = line+self.segid+self.elename+self.charge+"\n" 
            return line            

        line = self.ATOM+self.serial+" "+self.name+self.altloc+self.resname
        line = line+self.chain+self.resnum+self.icode+"   "
        line = line+self.x+self.y+self.z+self.occ+self.tempfac+"      "
        line = line+self.segid+self.elename+self.charge+"\n" 

        return line


class pdb_read:
    """
    Read different fields of pdb ATOM line
    """

    def __init__(self,line=""):

        if len(line) == 77 and position_read(line,1,4) == 'ATOM':
            line = line[:-1] + "    \n"            
            
        if len(line) != 81:
            line = " "*80+"\n"

        self.ATOM = position_read(line,1,6)
        self.serial = position_read(line,7,11)
        self.name = position_read(line,13,16)
        self.altloc = position_read(line,17)
        self.resname = position_read(line,18,20)
        self.chain = position_read(line,22)

        self.resnum = position_read(line,23,26)
        self.charmm_resnum = position_read(line,24,27)
        self.icode = position_read(line,27)
        if self.resnum != "    " and (int(self.resnum) < int(self.charmm_resnum)):
            self.resnum = self.charmm_resnum
            self.icode = " "

        self.x = position_read(line,31,38)
        self.y = position_read(line,39,46)
        self.z = position_read(line,47,54)
        self.occ = position_read(line,55,60)
        self.tempfac = position_read(line,61,66)
        self.segid = position_read(line,73,76)
        self.elename = position_read(line,77,78)
        self.charge = position_read(line,79,80)

        self.data = self.write()        

    def write(self):

        if self.resnum==self.charmm_resnum:
            line = self.ATOM+self.serial+" "+self.name+self.altloc+self.resname
            line = line+" "+self.chain+" "+self.resnum+"   "
            line = line+self.x+self.y+self.z+self.occ+self.tempfac+"      "
            line = line+self.segid+self.elename+self.charge+"\n" 
            return line            

        line = self.ATOM+self.serial+" "+self.name+self.altloc+self.resname
        line = line+" "+self.chain+self.resnum+self.icode+"   "
        line = line+self.x+self.y+self.z+self.occ+self.tempfac+"      "
        line = line+self.segid+self.elename+self.charge+"\n" 

        return line

class pdb:
    """
    Define a pdb file class
    """
    
    def __init__(self,file):
        self.filename = file.name
        self.file = file
        self.seglist = []
        self.reslist = []
        self.segreslist = []
        self.data = ""
        self.list = []
        self.segres = []
        temp_list  = []
        temp = [""]
        self.number_of_residues = 0
        self.number_of_segments = 0
        resnum = " "
        segid = " "
        line = read_relevant_line(self.file)
        fields = pdb_read(line)
        while line:
            self.data = self.data + line
            self.list.append(line)

            if not fields.resname in self.reslist:
                self.reslist.append(fields.resname)

            if not fields.segid in self.seglist:
                self.seglist.append(fields.segid)

            if fields.segid != segid:
                self.number_of_segments = self.number_of_segments + 1
                segid = fields.segid                
                self.segres.append(temp_list)
                temp_list = []

            if fields.resnum != resnum:
                self.number_of_residues = self.number_of_residues + 1
                resnum = fields.resnum
                temp_list.append(temp)
                temp = [""]

            temp.append(fields.write())
            line = read_relevant_line(self.file)
            fields = pdb_read(line)
            if not fields.segid in self.seglist:
                self.segreslist.append([segid,str(int(resnum))])
                
        temp_list.append(temp)
        self.segres.append(temp_list)
        self.file.seek(0,0)

        
    def atom(self,segid,resnum,name):
        """
        atom(segid,resnum,name) returns str data of that atom 
        """
        self.file.seek(0,0)
        self.atom_segid = strip(str(segid)).ljust(4)
        self.atom_resnum = strip(str(resnum)).rjust(4)
        self.atom_name = " "+ strip(str(name)).ljust(3)
        self.atom_data = ""
        self.atom_list = []
        line = read_relevant_line(self.file)
        while line:
            fields = pdb_read(line)

            if segid=='ALL':
                self.atom_segid = fields.segid

            if resnum=='ALL':
                self.atom_resnum = fields.resnum
                self.atom_resnum = fields.charmm_resnum

            if name=='ALL':
                self.atom_name = fields.name

            if int(fields.resnum) < int(fields.charmm_resnum):
                fields.resnum = fields.charmm_resnum

            if fields.segid==self.atom_segid and strip(fields.resnum)==strip(self.atom_resnum) and fields.name==self.atom_name:
                self.atom_data = self.atom_data + line
                self.atom_list.append(line)

            if segid!='ALL' and resnum!='ALL' and name!='ALL':
                self.atom_fields = fields
            else:
                self.atom_fields = pdb_read(" ")

            line = read_relevant_line(self.file)

        if self.data=="":
            print "No pdb entry found for segid %s, resnum %s, name %s" % (segid,resnum,name)
        
        return  self.atom_data

    def residue(self,segid,resnum):
        """
        residue(segid,resnum) returns str of that residue
        """
        return self.atom(segid,resnum,'ALL')

    def segid(self,segid):
        """
        segid(segid) returns str of that segment
        """
        return self.atom(segid,'ALL','ALL')

    def write(self,string):
        """
        Write data into pdb file
        """
        self.file.write(string)
        return 1

    def close(self):
        """
        close file
        """
        self.file.close()
        return 1


def check_line(line):
    """To check if the line is a valid line for pdb file in charmm
    valid line returns 1 while invalid line returns 0"""
    fields = pdb_read(line)
    if fields.ATOM=='ATOM  ' or fields.ATOM=='HETATM':
        if len(strip(fields.resname))==3 and fields.resname!='HOH':
            return 1
    return 0


def read_relevant_line(file):
    """
    To read the next relevant line from the raw pdb file
    """
    line1 = file.readline()        
    while (not check_line(line1)) and line1:
        line1 = file.readline()
    return line1


def charmm_compatible(input_file,output_file=' '):
   """
   Make a raw PDB file compatible for charmm reading
   """

   print "Make file %s into a charmm compatible file %s" % (input_file.name,output_file.name)
   filep = input_file
   filep.seek(0,0)
   if output_file == ' ':
       print " Making %s compatible for usage with charmm " % (input_file.name)
       out_filep = open('_temp_.pdb','w')
   else:
       print " Making %s --> %s compatible for usage with charmm " % (input_file.name,output_file.name)
       out_filep = output_file
   segid = 1
   resnum = 1
   line1 = read_relevant_line(filep)
   fields1 = pdb_read(line1) 
   if fields1.resnum and int(fields1.resnum)!=1:
       resnum = int(fields1.resnum)
   fields1.resnum = rjust(str(resnum),4)
   fields1.segid = 'E'+ zfill(str(segid),3)
   chain = fields1.chain
   fields1.chain = " "
   fields1.ATOM = 'ATOM  '
   fields1.elename = '  '
   out_filep.write(fields1.write())
   line2 = read_relevant_line(filep)

   while line2:
       fields2 = pdb_read(line2)
       if (fields1.resnum != fields2.resnum) or (fields1.resname != fields2.resname) or (fields2.name == ' N  '):
           resnum = resnum + 1
       original_resnum = fields2.resnum 
       fields2.resnum = rjust(str(resnum),4)
       original_segid = fields2.segid
       fields2.segid = fields1.segid
       if chain != fields2.chain: # or original_segid!=fields1.segid:
           resnum = 1
           if fields1.resnum and int(fields1.resnum)!=1:
               resnum = int(original_resnum)
           fields2.resnum = rjust(str(resnum),4)
           segid = segid + 1
           fields2.segid = 'E'+ zfill(str(segid),3)
       chain = fields2.chain
       fields2.chain=" "
       fields2.ATOM = 'ATOM  '
       fields2.elename = '  '
       out_filep.write(fields2.write())
       fields1 = fields2
       line2 = read_relevant_line(filep)

   if output_file=='_temp_.pdb':
       rename('_temp_.pdb',filep.name)

   return 1
 

def copy_coordinates(fields1,fields2):
    """
    Copy coordinates of one field to another
    """
    fields2.x = fields1.x
    fields2.y = fields1.y
    fields2.z = fields1.z
    return 1

def format_atom_name(atom_list):
    """
    format atom_list in correct length for usage
    """
    for i in range(0,len(atom_list)):
        atom_list[i] = " "+ strip(str(atom_list[i])).ljust(3)
    return 1


        
def copy_backbone(copy_from_file,copy_to_file,backbone=[' N  ',' CA ',' C  ',' O  '],adjust_sidechain_coor=0):
    """
    To copy backbone atoms of input file into output file
    """

    print "Copy coordinates in %s to %s" % (copy_from_file.name,copy_to_file.name)
    format_atom_name(backbone)
    pdbin = pdb(copy_from_file)
    pdbout = pdb(copy_to_file)
    j = 0
    new_pdb = []
    
    for i in range(0,len(pdbin.list)):
        fields_in = pdb_read(pdbin.list[i])
        residue_number = int(fields_in.resnum)
        while j < len(pdbout.list):
            fields_out = pdb_read(pdbout.list[j])
            if fields_in.name in backbone:
                # Note: In charmm resnum > 1000 are wrongly written into the pdb file
               if (fields_in.resnum == fields_out.resnum or fields_in.resnum == fields_out.charmm_resnum or fields_in.charmm_resnum == fields_out.charmm_resnum) and fields_in.name == fields_out.name : 
                  copy_coordinates(fields_in,fields_out)
                  new_pdb.append(fields_out.write()) 
                  j = j + 1
                  break
            new_pdb.append(fields_out.write())
            j = j + 1

    while j < len(pdbout.list):
        fields_out = pdb_read(pdbout.list[j])
        new_pdb.append(fields_out.write())
        j = j + 1

    new_pdb_data = ""
    for k in range(0,len(new_pdb)):
        new_pdb_data = new_pdb_data + new_pdb[k]
    pdbin.close()
    pdbout.close()
    copy_to_file = open(copy_to_file.name,'w')
    copy_to_file.write(new_pdb_data)
    #print new_pdb_data

    if adjust_sidechain_coor == 1:
        copy_to_file = open(copy_to_file.name,'r')
        copy_to_file.seek(0,0)
        adjust_sidechain(copy_to_file,backbone,2.5)
    return 1


def adjust_sidechain(input_file,backbone=[' N  ',' CA ',' C  ',' O  '],param=2.5,residue_number=5000):
    """
    To adjust the coordinates of sidechain atoms
    """

    print "Adjust sidechain coordinates in %s" % (input_file.name)
    format_atom_name(backbone)
    pdb1 = pdb(input_file)
    out_filep = open('_temp_.pdb','w')
    fields1 = pdb_read(pdb1.list[0])
    calpha = pdb_read(" ")
    if pdb1.number_of_segments != 1:
        print " number of segments in file %s is not 1" %(input_file.name)
        return 0

    for i in range(0,len(pdb1.list)):
        fields2 = pdb_read(pdb1.list[i])
        if calpha.resnum != fields2.resnum or calpha.charmm_resnum != fields2.charmm_resnum:
            for j in range(0,len(pdb1.segres[1][int(fields2.resnum)][:])):
                residue_atom = pdb_read(pdb1.segres[1][int(fields2.resnum)][j])
                if strip(residue_atom.name)=='CA':
                    calpha = residue_atom
                    break
        
        if fields2.name in backbone:
            fields1 = fields2
        else:
            fields2.x = '%8.3f' % (atof(calpha.x)+random()*param)
            fields2.y = '%8.3f' % (atof(calpha.y)+random()*param)
            fields2.z = '%8.3f' % (atof(calpha.z)+random()*param)
        
        out_filep.write(fields2.write())
        if residue_number == int(fields2.resnum):
            i = len(pdb1.list) # break
        
    rename('_temp_.pdb',input_file.name) 
    out_filep.close()
    return 1


def translate_coor(input_file,output_file,x=1,y=1,z=1,dist=0):
    """ 
    Translate coordinates of a pdb file
    """

    pdb1 = pdb(input_file)
    
    for i in range(0,len(pdb1.list)):
        fields1 = pdb_read(pdb1.list[i])
        fields1.x = '%8.3f' % ((x/sqrt((x*x+y*y+z*z)))*dist + atof(fields1.x))
        fields1.y = '%8.3f' % ((y/sqrt((x*x+y*y+z*z)))*dist + atof(fields1.y))
        fields1.z = '%8.3f' % ((z/sqrt((x*x+y*y+z*z)))*dist + atof(fields1.z))
        output_file.write(fields1.write())

    return 1


def adjust_overlapping_atoms(input_file):
    """
    To adjust the coordinates of sidechain atoms which overlap
    """

    print "Adjust sidechain coordinates in %s" % (input_file.name)
    pdb1 = pdb(input_file)
    out_filep = open('_temp_.pdb','w')

    if pdb1.number_of_segments != 1:
        print " number of segments in file %s is not 1" %(input_file.name)
        return 0

    for i in range(0,len(pdb1.list)):
        fields1 = pdb_read(pdb1.list[i])
        for j in range(i+1,i+3):
            if j < len(pdb1.list):
                fields2 = pdb_read(pdb1.list[j])
                if fields1.x==fields2.x or fields1.y==fields2.y or fields1.z==fields2.z:
                    fields2.x = '%8.3f' % (atof(fields1.x)+0.1*(j-i))
                    fields2.y = '%8.3f' % (atof(fields1.y)+0.1*(j-i))
                    fields2.z = '%8.3f' % (atof(fields1.z)+0.1*(j-i))
                    pdb1.list[j] = fields2.write()
                
    for i in range(0,len(pdb1.list)):
        out_filep.write(pdb1.list[i])

        
    rename('_temp_.pdb',input_file.name) 
    out_filep.close()
    return 1
        

###################################################################
######## User interface functions starts here #####################
# These functions make input, putput easier to handle for a user ##
###################################################################


def check_file(file_name):
    """
    To check if a file exists or is empty
    """
    try:
        filep = open(file_name,'r')
        if filep.readline():
            return 1
        else:
            print filep.name, "file is empty"
            return 0
    except IOError:
        print filep.name, "file does not exist"
        return 0


    
def user_charmm_compatible(inp_file_name,out_file_name=' '):
    """ 
    To make a input pdb file charmm compatible pdb format
    """

    if not check_file(inp_file_name):
        print "Nothing Done"
        return 0

    input_filep = open(inp_file_name,'r')
    if out_file_name != ' ':
        output_filep = open(out_file_name, 'w')

    charmm_compatible(input_filep,output_filep)
    input_filep.close()
    output_filep.close()
    return 1


def user_copy_coordinates(from_file,to_file,atom_list=[' N  ',' CA ',' C  ',' O  '],adjust_sidechain_coor=0):
    """
    Suppose you have 2 pdb file of the same protein/molecule, and
    if you want to copy coordinates of a subset of atoms from one pdb
    file in to another retaining the coordinates of other atoms, then 
    this function can be used.
    """

    if not check_file(from_file):
        print "Nothing Done"
        return 0

    if not check_file(to_file):
        print "Nothing Done"
        return 0

    input_filep = open(from_file,'r')
    output_filep = open(to_file, 'r')

    copy_backbone(input_filep,output_filep,atom_list,adjust_sidechain_coor)
    input_filep.close()
    output_filep.close()
    return 1

def user_translate_coor(from_file,to_file,x,y,z,dist):
    """ 
    To translate coordinates in a pdb file by certain distance
    """

    if not check_file(from_file):
        print "Nothing Done"
        return 0

    input_filep = open(from_file,'r')
    output_filep = open(to_file, 'w')

    translate_coor(input_filep,output_filep,x,y,z,dist)
    input_filep.close()
    output_filep.close()
    return 1
    

def user_adjust_sidechain(inp_file_name,backbone=[' N  ',' CA ',' C  ',' O  '],param=2.5,residue_number=5000):
    """
    If a pdb has random coordinates for sidechain atoms in all 
    residues (<residue_number), then one can use random coordinates 
    to sidechain atoms using this function.
    This will randomly place the sidechain atoms close to the backbone atoms,
    after which they can be easily energy minimized.
    param - is to set how far the sidechain atoms are from the 
    backbone atoms.
    """
        
    if not check_file(inp_file_name):
        print "Nothing Done"
        return 0

    input_filep = open(inp_file_name,'r')

    adjust_sidechain(input_filep,backbone,residue_number)
    return 1


def user_adjust_overlapping_atoms(inp_file_name):
    """ 
    If there exists overlapping atoms in a pdb file this can hinder minimization
    using gradiant descent.
    So adjust the overlapping atoms slightly to enable minimization.
    """
        
    if not check_file(inp_file_name):
        print "Nothing Done"
        return 0

    input_filep = open(inp_file_name,'r')

    adjust_overlapping_atoms(input_filep)
    return 1




def user_segment_split(inp_file_name,var_name='raw00'):
    """ 
    To split a pdb into different pdbs by segment name 
    """

    if not check_file(inp_file_name):
        print "Nothing Done"
        return 0
    
    input_filep = open(inp_file_name,'r')
    pdb1 = pdb(input_filep)
    for i in range(0, len(pdb1.seglist)):
        output_filep = open(var_name+str(i+1)+'.pdb','w')
        output_filep.write(pdb1.atom(pdb1.seglist[i],'ALL','ALL'))
        output_filep.close()
    pdb1.close()
    print "number of residues = ", pdb1.segreslist
    return 1
